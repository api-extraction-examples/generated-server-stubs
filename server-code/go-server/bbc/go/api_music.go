/*
 * Radio & Music Services
 *
 * We encapsulate Radio & Music business logic for iPlayer Radio and BBC Music products on all platforms. We add value by reliably providing the right blend of metadata needed by clients.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"encoding/json"
	"net/http"
	"strings"

	"github.com/gorilla/mux"
)

// MusicAPIController binds http requests to an api service and writes the service results to the http response
type MusicAPIController struct {
	service MusicAPIServicer
	errorHandler ErrorHandler
}

// MusicAPIOption for how the controller is set up.
type MusicAPIOption func(*MusicAPIController)

// WithMusicAPIErrorHandler inject ErrorHandler into controller
func WithMusicAPIErrorHandler(h ErrorHandler) MusicAPIOption {
	return func(c *MusicAPIController) {
		c.errorHandler = h
	}
}

// NewMusicAPIController creates a default api controller
func NewMusicAPIController(s MusicAPIServicer, opts ...MusicAPIOption) Router {
	controller := &MusicAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the MusicAPIController
func (c *MusicAPIController) Routes() Routes {
	return Routes{
		"DeletePersonalisedMusicFavouritesByTypeById": Route{
			strings.ToUpper("Delete"),
			"/my/music/favourites/{type}/{id}",
			c.DeletePersonalisedMusicFavouritesByTypeById,
		},
		"DeletePersonalisedMusicFollowsByTypeById": Route{
			strings.ToUpper("Delete"),
			"/my/music/follows/{type}/{id}",
			c.DeletePersonalisedMusicFollowsByTypeById,
		},
		"GetMusicPopularArtistById": Route{
			strings.ToUpper("Get"),
			"/music/popular/artists/{id}",
			c.GetMusicPopularArtistById,
		},
		"GetMusicPopularArtists": Route{
			strings.ToUpper("Get"),
			"/music/popular/artists",
			c.GetMusicPopularArtists,
		},
		"GetMusicPopularPlaylistById": Route{
			strings.ToUpper("Get"),
			"/music/popular/playlists/{id}",
			c.GetMusicPopularPlaylistById,
		},
		"GetMusicPopularPlaylists": Route{
			strings.ToUpper("Get"),
			"/music/popular/playlists",
			c.GetMusicPopularPlaylists,
		},
		"GetMusicPopularTrackById": Route{
			strings.ToUpper("Get"),
			"/music/popular/tracks/{id}",
			c.GetMusicPopularTrackById,
		},
		"GetMusicPopularTracks": Route{
			strings.ToUpper("Get"),
			"/music/popular/tracks",
			c.GetMusicPopularTracks,
		},
		"GetPersonalisedMusicFavourites": Route{
			strings.ToUpper("Get"),
			"/my/music/favourites",
			c.GetPersonalisedMusicFavourites,
		},
		"GetPersonalisedMusicFavouritesByType": Route{
			strings.ToUpper("Get"),
			"/my/music/favourites/{type}",
			c.GetPersonalisedMusicFavouritesByType,
		},
		"GetPersonalisedMusicFavouritesByTypeById": Route{
			strings.ToUpper("Get"),
			"/my/music/favourites/{type}/{id}",
			c.GetPersonalisedMusicFavouritesByTypeById,
		},
		"GetPersonalisedMusicFollows": Route{
			strings.ToUpper("Get"),
			"/my/music/follows",
			c.GetPersonalisedMusicFollows,
		},
		"GetPersonalisedMusicFollowsByType": Route{
			strings.ToUpper("Get"),
			"/my/music/follows/{type}",
			c.GetPersonalisedMusicFollowsByType,
		},
		"GetPersonalisedMusicFollowsByTypeById": Route{
			strings.ToUpper("Get"),
			"/my/music/follows/{type}/{id}",
			c.GetPersonalisedMusicFollowsByTypeById,
		},
		"PostPersonalisedMusicFavouritesBatch": Route{
			strings.ToUpper("Post"),
			"/my/music/favourites",
			c.PostPersonalisedMusicFavouritesBatch,
		},
		"PostPersonalisedMusicFavouritesByTypeById": Route{
			strings.ToUpper("Post"),
			"/my/music/favourites/{type}/{id}",
			c.PostPersonalisedMusicFavouritesByTypeById,
		},
		"PostPersonalisedMusicFollowsBatch": Route{
			strings.ToUpper("Post"),
			"/my/music/follows",
			c.PostPersonalisedMusicFollowsBatch,
		},
		"PostPersonalisedMusicFollowsByTypeById": Route{
			strings.ToUpper("Post"),
			"/my/music/follows/{type}/{id}",
			c.PostPersonalisedMusicFollowsByTypeById,
		},
		"PutPersonalisedMusicFavouritesBatch": Route{
			strings.ToUpper("Put"),
			"/my/music/favourites",
			c.PutPersonalisedMusicFavouritesBatch,
		},
		"PutPersonalisedMusicFavouritesByTypeById": Route{
			strings.ToUpper("Put"),
			"/my/music/favourites/{type}/{id}",
			c.PutPersonalisedMusicFavouritesByTypeById,
		},
		"PutPersonalisedMusicFollowsBatch": Route{
			strings.ToUpper("Put"),
			"/my/music/follows",
			c.PutPersonalisedMusicFollowsBatch,
		},
		"PutPersonalisedMusicFollowsByTypeById": Route{
			strings.ToUpper("Put"),
			"/my/music/follows/{type}/{id}",
			c.PutPersonalisedMusicFollowsByTypeById,
		},
	}
}

// DeletePersonalisedMusicFavouritesByTypeById - Favourite Track or Clip
func (c *MusicAPIController) DeletePersonalisedMusicFavouritesByTypeById(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	authorizationParam := r.Header.Get("Authorization")
	xAuthenticationProviderParam := r.Header.Get("X-Authentication-Provider")
	xAPIKeyParam := r.Header.Get("X-API-Key")
	type_Param := params["type"]
	if type_Param == "" {
		c.errorHandler(w, r, &RequiredError{"type"}, nil)
		return
	}
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	result, err := c.service.DeletePersonalisedMusicFavouritesByTypeById(r.Context(), authorizationParam, xAuthenticationProviderParam, xAPIKeyParam, type_Param, idParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// DeletePersonalisedMusicFollowsByTypeById - Followed Network, Category, Artist, Playlist and Genre
func (c *MusicAPIController) DeletePersonalisedMusicFollowsByTypeById(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	authorizationParam := r.Header.Get("Authorization")
	xAuthenticationProviderParam := r.Header.Get("X-Authentication-Provider")
	xAPIKeyParam := r.Header.Get("X-API-Key")
	type_Param := params["type"]
	if type_Param == "" {
		c.errorHandler(w, r, &RequiredError{"type"}, nil)
		return
	}
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var musicDataParam bool
	if query.Has("music-data") {
		param, err := parseBoolParameter(
			query.Get("music-data"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicDataParam = param
	} else {
	}
	var musicContextParam string
	if query.Has("music_context") {
		param := query.Get("music_context")

		musicContextParam = param
	} else {
	}
	var musicWithinUkParam bool
	if query.Has("music_within_uk") {
		param, err := parseBoolParameter(
			query.Get("music_within_uk"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicWithinUkParam = param
	} else {
	}
	result, err := c.service.DeletePersonalisedMusicFollowsByTypeById(r.Context(), authorizationParam, xAuthenticationProviderParam, xAPIKeyParam, type_Param, idParam, musicDataParam, musicContextParam, musicWithinUkParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetMusicPopularArtistById - Single Artist Popularity
func (c *MusicAPIController) GetMusicPopularArtistById(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	xAPIKeyParam := r.Header.Get("X-API-Key")
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var sinceParam string
	if query.Has("since") {
		param := query.Get("since")

		sinceParam = param
	} else {
	}
	var untilParam string
	if query.Has("until") {
		param := query.Get("until")

		untilParam = param
	} else {
	}
	var decomposedParam bool
	if query.Has("decomposed") {
		param, err := parseBoolParameter(
			query.Get("decomposed"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		decomposedParam = param
	} else {
	}
	result, err := c.service.GetMusicPopularArtistById(r.Context(), xAPIKeyParam, idParam, sinceParam, untilParam, decomposedParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetMusicPopularArtists - Popular Artists
func (c *MusicAPIController) GetMusicPopularArtists(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	xAPIKeyParam := r.Header.Get("X-API-Key")
	var sinceParam string
	if query.Has("since") {
		param := query.Get("since")

		sinceParam = param
	} else {
	}
	var untilParam string
	if query.Has("until") {
		param := query.Get("until")

		untilParam = param
	} else {
	}
	var decomposedParam bool
	if query.Has("decomposed") {
		param, err := parseBoolParameter(
			query.Get("decomposed"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		decomposedParam = param
	} else {
	}
	var offsetParam int32
	if query.Has("offset") {
		param, err := parseNumericParameter[int32](
			query.Get("offset"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		offsetParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	result, err := c.service.GetMusicPopularArtists(r.Context(), xAPIKeyParam, sinceParam, untilParam, decomposedParam, offsetParam, limitParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetMusicPopularPlaylistById - Single Playlist Popularity
func (c *MusicAPIController) GetMusicPopularPlaylistById(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	xAPIKeyParam := r.Header.Get("X-API-Key")
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var sinceParam string
	if query.Has("since") {
		param := query.Get("since")

		sinceParam = param
	} else {
	}
	var untilParam string
	if query.Has("until") {
		param := query.Get("until")

		untilParam = param
	} else {
	}
	var decomposedParam bool
	if query.Has("decomposed") {
		param, err := parseBoolParameter(
			query.Get("decomposed"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		decomposedParam = param
	} else {
	}
	result, err := c.service.GetMusicPopularPlaylistById(r.Context(), xAPIKeyParam, idParam, sinceParam, untilParam, decomposedParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetMusicPopularPlaylists - Popular Playlists
func (c *MusicAPIController) GetMusicPopularPlaylists(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	xAPIKeyParam := r.Header.Get("X-API-Key")
	var sinceParam string
	if query.Has("since") {
		param := query.Get("since")

		sinceParam = param
	} else {
	}
	var untilParam string
	if query.Has("until") {
		param := query.Get("until")

		untilParam = param
	} else {
	}
	var decomposedParam bool
	if query.Has("decomposed") {
		param, err := parseBoolParameter(
			query.Get("decomposed"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		decomposedParam = param
	} else {
	}
	var offsetParam int32
	if query.Has("offset") {
		param, err := parseNumericParameter[int32](
			query.Get("offset"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		offsetParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	result, err := c.service.GetMusicPopularPlaylists(r.Context(), xAPIKeyParam, sinceParam, untilParam, decomposedParam, offsetParam, limitParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetMusicPopularTrackById - Single Track Popularity
func (c *MusicAPIController) GetMusicPopularTrackById(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	xAPIKeyParam := r.Header.Get("X-API-Key")
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var sinceParam string
	if query.Has("since") {
		param := query.Get("since")

		sinceParam = param
	} else {
	}
	var untilParam string
	if query.Has("until") {
		param := query.Get("until")

		untilParam = param
	} else {
	}
	var networkParam string
	if query.Has("network") {
		param := query.Get("network")

		networkParam = param
	} else {
	}
	var programmeParam string
	if query.Has("programme") {
		param := query.Get("programme")

		programmeParam = param
	} else {
	}
	var artistParam string
	if query.Has("artist") {
		param := query.Get("artist")

		artistParam = param
	} else {
	}
	var decomposedParam bool
	if query.Has("decomposed") {
		param, err := parseBoolParameter(
			query.Get("decomposed"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		decomposedParam = param
	} else {
	}
	result, err := c.service.GetMusicPopularTrackById(r.Context(), xAPIKeyParam, idParam, sinceParam, untilParam, networkParam, programmeParam, artistParam, decomposedParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetMusicPopularTracks - Popular Tracks
func (c *MusicAPIController) GetMusicPopularTracks(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	xAPIKeyParam := r.Header.Get("X-API-Key")
	var sinceParam string
	if query.Has("since") {
		param := query.Get("since")

		sinceParam = param
	} else {
	}
	var untilParam string
	if query.Has("until") {
		param := query.Get("until")

		untilParam = param
	} else {
	}
	var networkParam string
	if query.Has("network") {
		param := query.Get("network")

		networkParam = param
	} else {
	}
	var programmeParam string
	if query.Has("programme") {
		param := query.Get("programme")

		programmeParam = param
	} else {
	}
	var artistParam string
	if query.Has("artist") {
		param := query.Get("artist")

		artistParam = param
	} else {
	}
	var decomposedParam bool
	if query.Has("decomposed") {
		param, err := parseBoolParameter(
			query.Get("decomposed"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		decomposedParam = param
	} else {
	}
	var offsetParam int32
	if query.Has("offset") {
		param, err := parseNumericParameter[int32](
			query.Get("offset"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		offsetParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	result, err := c.service.GetMusicPopularTracks(r.Context(), xAPIKeyParam, sinceParam, untilParam, networkParam, programmeParam, artistParam, decomposedParam, offsetParam, limitParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetPersonalisedMusicFavourites - Favourite Tracks or Clips
func (c *MusicAPIController) GetPersonalisedMusicFavourites(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	authorizationParam := r.Header.Get("Authorization")
	xAuthenticationProviderParam := r.Header.Get("X-Authentication-Provider")
	xAPIKeyParam := r.Header.Get("X-API-Key")
	var offsetParam int32
	if query.Has("offset") {
		param, err := parseNumericParameter[int32](
			query.Get("offset"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		offsetParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var actionParam string
	if query.Has("action") {
		param := query.Get("action")

		actionParam = param
	} else {
	}
	var musicDataParam bool
	if query.Has("music-data") {
		param, err := parseBoolParameter(
			query.Get("music-data"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicDataParam = param
	} else {
	}
	result, err := c.service.GetPersonalisedMusicFavourites(r.Context(), authorizationParam, xAuthenticationProviderParam, xAPIKeyParam, offsetParam, limitParam, actionParam, musicDataParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetPersonalisedMusicFavouritesByType - Favourite Tracks or Clips by Type
func (c *MusicAPIController) GetPersonalisedMusicFavouritesByType(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	authorizationParam := r.Header.Get("Authorization")
	xAuthenticationProviderParam := r.Header.Get("X-Authentication-Provider")
	xAPIKeyParam := r.Header.Get("X-API-Key")
	type_Param := params["type"]
	if type_Param == "" {
		c.errorHandler(w, r, &RequiredError{"type"}, nil)
		return
	}
	var actionParam string
	if query.Has("action") {
		param := query.Get("action")

		actionParam = param
	} else {
	}
	var offsetParam int32
	if query.Has("offset") {
		param, err := parseNumericParameter[int32](
			query.Get("offset"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		offsetParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	result, err := c.service.GetPersonalisedMusicFavouritesByType(r.Context(), authorizationParam, xAuthenticationProviderParam, xAPIKeyParam, type_Param, actionParam, offsetParam, limitParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetPersonalisedMusicFavouritesByTypeById - Favourite Track or Clip
func (c *MusicAPIController) GetPersonalisedMusicFavouritesByTypeById(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	authorizationParam := r.Header.Get("Authorization")
	xAuthenticationProviderParam := r.Header.Get("X-Authentication-Provider")
	xAPIKeyParam := r.Header.Get("X-API-Key")
	type_Param := params["type"]
	if type_Param == "" {
		c.errorHandler(w, r, &RequiredError{"type"}, nil)
		return
	}
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	result, err := c.service.GetPersonalisedMusicFavouritesByTypeById(r.Context(), authorizationParam, xAuthenticationProviderParam, xAPIKeyParam, type_Param, idParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetPersonalisedMusicFollows - Followed Networks, Categories, Artists, Playlists and Genres
func (c *MusicAPIController) GetPersonalisedMusicFollows(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	authorizationParam := r.Header.Get("Authorization")
	xAuthenticationProviderParam := r.Header.Get("X-Authentication-Provider")
	xAPIKeyParam := r.Header.Get("X-API-Key")
	var actionParam string
	if query.Has("action") {
		param := query.Get("action")

		actionParam = param
	} else {
	}
	var musicDataParam bool
	if query.Has("music-data") {
		param, err := parseBoolParameter(
			query.Get("music-data"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicDataParam = param
	} else {
	}
	var musicContextParam string
	if query.Has("music_context") {
		param := query.Get("music_context")

		musicContextParam = param
	} else {
	}
	var musicWithinUkParam bool
	if query.Has("music_within_uk") {
		param, err := parseBoolParameter(
			query.Get("music_within_uk"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicWithinUkParam = param
	} else {
	}
	var offsetParam int32
	if query.Has("offset") {
		param, err := parseNumericParameter[int32](
			query.Get("offset"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		offsetParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	result, err := c.service.GetPersonalisedMusicFollows(r.Context(), authorizationParam, xAuthenticationProviderParam, xAPIKeyParam, actionParam, musicDataParam, musicContextParam, musicWithinUkParam, offsetParam, limitParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetPersonalisedMusicFollowsByType - Followed Networks, Categories, Artists, Playlists and Genres by Type
func (c *MusicAPIController) GetPersonalisedMusicFollowsByType(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	authorizationParam := r.Header.Get("Authorization")
	xAuthenticationProviderParam := r.Header.Get("X-Authentication-Provider")
	xAPIKeyParam := r.Header.Get("X-API-Key")
	type_Param := params["type"]
	if type_Param == "" {
		c.errorHandler(w, r, &RequiredError{"type"}, nil)
		return
	}
	var actionParam string
	if query.Has("action") {
		param := query.Get("action")

		actionParam = param
	} else {
	}
	var musicDataParam bool
	if query.Has("music-data") {
		param, err := parseBoolParameter(
			query.Get("music-data"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicDataParam = param
	} else {
	}
	var musicContextParam string
	if query.Has("music_context") {
		param := query.Get("music_context")

		musicContextParam = param
	} else {
	}
	var musicWithinUkParam bool
	if query.Has("music_within_uk") {
		param, err := parseBoolParameter(
			query.Get("music_within_uk"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicWithinUkParam = param
	} else {
	}
	var offsetParam int32
	if query.Has("offset") {
		param, err := parseNumericParameter[int32](
			query.Get("offset"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		offsetParam = param
	} else {
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	result, err := c.service.GetPersonalisedMusicFollowsByType(r.Context(), authorizationParam, xAuthenticationProviderParam, xAPIKeyParam, type_Param, actionParam, musicDataParam, musicContextParam, musicWithinUkParam, offsetParam, limitParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetPersonalisedMusicFollowsByTypeById - Followed Network, Category, Artist, Playlist and Genre
func (c *MusicAPIController) GetPersonalisedMusicFollowsByTypeById(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	authorizationParam := r.Header.Get("Authorization")
	xAuthenticationProviderParam := r.Header.Get("X-Authentication-Provider")
	xAPIKeyParam := r.Header.Get("X-API-Key")
	type_Param := params["type"]
	if type_Param == "" {
		c.errorHandler(w, r, &RequiredError{"type"}, nil)
		return
	}
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var musicDataParam bool
	if query.Has("music-data") {
		param, err := parseBoolParameter(
			query.Get("music-data"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicDataParam = param
	} else {
	}
	var musicContextParam string
	if query.Has("music_context") {
		param := query.Get("music_context")

		musicContextParam = param
	} else {
	}
	var musicWithinUkParam bool
	if query.Has("music_within_uk") {
		param, err := parseBoolParameter(
			query.Get("music_within_uk"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicWithinUkParam = param
	} else {
	}
	result, err := c.service.GetPersonalisedMusicFollowsByTypeById(r.Context(), authorizationParam, xAuthenticationProviderParam, xAPIKeyParam, type_Param, idParam, musicDataParam, musicContextParam, musicWithinUkParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// PostPersonalisedMusicFavouritesBatch - Favourite Tracks or Clips
func (c *MusicAPIController) PostPersonalisedMusicFavouritesBatch(w http.ResponseWriter, r *http.Request) {
	authorizationParam := r.Header.Get("Authorization")
	xAuthenticationProviderParam := r.Header.Get("X-Authentication-Provider")
	xAPIKeyParam := r.Header.Get("X-API-Key")
	bodyParam := []PersonalisedMusicBatchRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&bodyParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	for _, el := range bodyParam {
		if err := AssertPersonalisedMusicBatchRequestRequired(el); err != nil {
			c.errorHandler(w, r, err, nil)
			return
		}
	}
	result, err := c.service.PostPersonalisedMusicFavouritesBatch(r.Context(), authorizationParam, xAuthenticationProviderParam, xAPIKeyParam, bodyParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// PostPersonalisedMusicFavouritesByTypeById - Favourite Track or Clip
func (c *MusicAPIController) PostPersonalisedMusicFavouritesByTypeById(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	authorizationParam := r.Header.Get("Authorization")
	xAuthenticationProviderParam := r.Header.Get("X-Authentication-Provider")
	xAPIKeyParam := r.Header.Get("X-API-Key")
	type_Param := params["type"]
	if type_Param == "" {
		c.errorHandler(w, r, &RequiredError{"type"}, nil)
		return
	}
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	bodyParam := PersonalisedMusicRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&bodyParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertPersonalisedMusicRequestRequired(bodyParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertPersonalisedMusicRequestConstraints(bodyParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.PostPersonalisedMusicFavouritesByTypeById(r.Context(), authorizationParam, xAuthenticationProviderParam, xAPIKeyParam, type_Param, idParam, bodyParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// PostPersonalisedMusicFollowsBatch - Followed Networks, Categories, Artists, Playlists and Genres
func (c *MusicAPIController) PostPersonalisedMusicFollowsBatch(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	authorizationParam := r.Header.Get("Authorization")
	xAuthenticationProviderParam := r.Header.Get("X-Authentication-Provider")
	xAPIKeyParam := r.Header.Get("X-API-Key")
	bodyParam := []PersonalisedMusicBatchRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&bodyParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	for _, el := range bodyParam {
		if err := AssertPersonalisedMusicBatchRequestRequired(el); err != nil {
			c.errorHandler(w, r, err, nil)
			return
		}
	}
	var actionParam string
	if query.Has("action") {
		param := query.Get("action")

		actionParam = param
	} else {
	}
	var musicDataParam bool
	if query.Has("music-data") {
		param, err := parseBoolParameter(
			query.Get("music-data"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicDataParam = param
	} else {
	}
	var musicContextParam string
	if query.Has("music_context") {
		param := query.Get("music_context")

		musicContextParam = param
	} else {
	}
	var musicWithinUkParam bool
	if query.Has("music_within_uk") {
		param, err := parseBoolParameter(
			query.Get("music_within_uk"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicWithinUkParam = param
	} else {
	}
	result, err := c.service.PostPersonalisedMusicFollowsBatch(r.Context(), authorizationParam, xAuthenticationProviderParam, xAPIKeyParam, bodyParam, actionParam, musicDataParam, musicContextParam, musicWithinUkParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// PostPersonalisedMusicFollowsByTypeById - Followed Network, Category, Artist, Playlist and Genre
func (c *MusicAPIController) PostPersonalisedMusicFollowsByTypeById(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	authorizationParam := r.Header.Get("Authorization")
	xAuthenticationProviderParam := r.Header.Get("X-Authentication-Provider")
	xAPIKeyParam := r.Header.Get("X-API-Key")
	type_Param := params["type"]
	if type_Param == "" {
		c.errorHandler(w, r, &RequiredError{"type"}, nil)
		return
	}
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	bodyParam := PersonalisedMusicRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&bodyParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertPersonalisedMusicRequestRequired(bodyParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertPersonalisedMusicRequestConstraints(bodyParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	var musicDataParam bool
	if query.Has("music-data") {
		param, err := parseBoolParameter(
			query.Get("music-data"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicDataParam = param
	} else {
	}
	var musicContextParam string
	if query.Has("music_context") {
		param := query.Get("music_context")

		musicContextParam = param
	} else {
	}
	var musicWithinUkParam bool
	if query.Has("music_within_uk") {
		param, err := parseBoolParameter(
			query.Get("music_within_uk"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicWithinUkParam = param
	} else {
	}
	result, err := c.service.PostPersonalisedMusicFollowsByTypeById(r.Context(), authorizationParam, xAuthenticationProviderParam, xAPIKeyParam, type_Param, idParam, bodyParam, musicDataParam, musicContextParam, musicWithinUkParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// PutPersonalisedMusicFavouritesBatch - Favourite Tracks or Clips
func (c *MusicAPIController) PutPersonalisedMusicFavouritesBatch(w http.ResponseWriter, r *http.Request) {
	authorizationParam := r.Header.Get("Authorization")
	xAuthenticationProviderParam := r.Header.Get("X-Authentication-Provider")
	xAPIKeyParam := r.Header.Get("X-API-Key")
	bodyParam := []PersonalisedMusicBatchRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&bodyParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	for _, el := range bodyParam {
		if err := AssertPersonalisedMusicBatchRequestRequired(el); err != nil {
			c.errorHandler(w, r, err, nil)
			return
		}
	}
	result, err := c.service.PutPersonalisedMusicFavouritesBatch(r.Context(), authorizationParam, xAuthenticationProviderParam, xAPIKeyParam, bodyParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// PutPersonalisedMusicFavouritesByTypeById - Favourite Track or Clip
func (c *MusicAPIController) PutPersonalisedMusicFavouritesByTypeById(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	authorizationParam := r.Header.Get("Authorization")
	xAuthenticationProviderParam := r.Header.Get("X-Authentication-Provider")
	xAPIKeyParam := r.Header.Get("X-API-Key")
	type_Param := params["type"]
	if type_Param == "" {
		c.errorHandler(w, r, &RequiredError{"type"}, nil)
		return
	}
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	bodyParam := PersonalisedMusicRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&bodyParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertPersonalisedMusicRequestRequired(bodyParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertPersonalisedMusicRequestConstraints(bodyParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.PutPersonalisedMusicFavouritesByTypeById(r.Context(), authorizationParam, xAuthenticationProviderParam, xAPIKeyParam, type_Param, idParam, bodyParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// PutPersonalisedMusicFollowsBatch - Followed Networks, Categories, Artists, Playlists and Genres
func (c *MusicAPIController) PutPersonalisedMusicFollowsBatch(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	authorizationParam := r.Header.Get("Authorization")
	xAuthenticationProviderParam := r.Header.Get("X-Authentication-Provider")
	xAPIKeyParam := r.Header.Get("X-API-Key")
	bodyParam := []PersonalisedMusicBatchRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&bodyParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	for _, el := range bodyParam {
		if err := AssertPersonalisedMusicBatchRequestRequired(el); err != nil {
			c.errorHandler(w, r, err, nil)
			return
		}
	}
	var actionParam string
	if query.Has("action") {
		param := query.Get("action")

		actionParam = param
	} else {
	}
	var musicDataParam bool
	if query.Has("music-data") {
		param, err := parseBoolParameter(
			query.Get("music-data"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicDataParam = param
	} else {
	}
	var musicContextParam string
	if query.Has("music_context") {
		param := query.Get("music_context")

		musicContextParam = param
	} else {
	}
	var musicWithinUkParam bool
	if query.Has("music_within_uk") {
		param, err := parseBoolParameter(
			query.Get("music_within_uk"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicWithinUkParam = param
	} else {
	}
	result, err := c.service.PutPersonalisedMusicFollowsBatch(r.Context(), authorizationParam, xAuthenticationProviderParam, xAPIKeyParam, bodyParam, actionParam, musicDataParam, musicContextParam, musicWithinUkParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// PutPersonalisedMusicFollowsByTypeById - Followed Network, Category, Artist, Playlist and Genre
func (c *MusicAPIController) PutPersonalisedMusicFollowsByTypeById(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	authorizationParam := r.Header.Get("Authorization")
	xAuthenticationProviderParam := r.Header.Get("X-Authentication-Provider")
	xAPIKeyParam := r.Header.Get("X-API-Key")
	type_Param := params["type"]
	if type_Param == "" {
		c.errorHandler(w, r, &RequiredError{"type"}, nil)
		return
	}
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	bodyParam := PersonalisedMusicRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&bodyParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertPersonalisedMusicRequestRequired(bodyParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertPersonalisedMusicRequestConstraints(bodyParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	var musicDataParam bool
	if query.Has("music-data") {
		param, err := parseBoolParameter(
			query.Get("music-data"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicDataParam = param
	} else {
	}
	var musicContextParam string
	if query.Has("music_context") {
		param := query.Get("music_context")

		musicContextParam = param
	} else {
	}
	var musicWithinUkParam bool
	if query.Has("music_within_uk") {
		param, err := parseBoolParameter(
			query.Get("music_within_uk"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		musicWithinUkParam = param
	} else {
	}
	result, err := c.service.PutPersonalisedMusicFollowsByTypeById(r.Context(), authorizationParam, xAuthenticationProviderParam, xAPIKeyParam, type_Param, idParam, bodyParam, musicDataParam, musicContextParam, musicWithinUkParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}
