/*
 * Jellyfin API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: v1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"encoding/json"
	"net/http"
	"strings"

	"github.com/gorilla/mux"
)

// MediaInfoAPIController binds http requests to an api service and writes the service results to the http response
type MediaInfoAPIController struct {
	service MediaInfoAPIServicer
	errorHandler ErrorHandler
}

// MediaInfoAPIOption for how the controller is set up.
type MediaInfoAPIOption func(*MediaInfoAPIController)

// WithMediaInfoAPIErrorHandler inject ErrorHandler into controller
func WithMediaInfoAPIErrorHandler(h ErrorHandler) MediaInfoAPIOption {
	return func(c *MediaInfoAPIController) {
		c.errorHandler = h
	}
}

// NewMediaInfoAPIController creates a default api controller
func NewMediaInfoAPIController(s MediaInfoAPIServicer, opts ...MediaInfoAPIOption) Router {
	controller := &MediaInfoAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the MediaInfoAPIController
func (c *MediaInfoAPIController) Routes() Routes {
	return Routes{
		"CloseLiveStream": Route{
			strings.ToUpper("Post"),
			"/LiveStreams/Close",
			c.CloseLiveStream,
		},
		"GetBitrateTestBytes": Route{
			strings.ToUpper("Get"),
			"/Playback/BitrateTest",
			c.GetBitrateTestBytes,
		},
		"GetPlaybackInfo": Route{
			strings.ToUpper("Get"),
			"/Items/{itemId}/PlaybackInfo",
			c.GetPlaybackInfo,
		},
		"GetPostedPlaybackInfo": Route{
			strings.ToUpper("Post"),
			"/Items/{itemId}/PlaybackInfo",
			c.GetPostedPlaybackInfo,
		},
		"OpenLiveStream": Route{
			strings.ToUpper("Post"),
			"/LiveStreams/Open",
			c.OpenLiveStream,
		},
	}
}

// CloseLiveStream - Closes a media source.
func (c *MediaInfoAPIController) CloseLiveStream(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	var liveStreamIdParam string
	if query.Has("liveStreamId") {
		param := query.Get("liveStreamId")

		liveStreamIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "liveStreamId"}, nil)
		return
	}
	result, err := c.service.CloseLiveStream(r.Context(), liveStreamIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetBitrateTestBytes - Tests the network with a request with the size of the bitrate.
func (c *MediaInfoAPIController) GetBitrateTestBytes(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	var sizeParam int32
	if query.Has("size") {
		param, err := parseNumericParameter[int32](
			query.Get("size"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		sizeParam = param
	} else {
		var param int32 = 102400
		sizeParam = param
	}
	result, err := c.service.GetBitrateTestBytes(r.Context(), sizeParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetPlaybackInfo - Gets live playback media info for an item.
func (c *MediaInfoAPIController) GetPlaybackInfo(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	itemIdParam := params["itemId"]
	if itemIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"itemId"}, nil)
		return
	}
	var userIdParam string
	if query.Has("userId") {
		param := query.Get("userId")

		userIdParam = param
	} else {
		c.errorHandler(w, r, &RequiredError{Field: "userId"}, nil)
		return
	}
	result, err := c.service.GetPlaybackInfo(r.Context(), itemIdParam, userIdParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetPostedPlaybackInfo - Gets live playback media info for an item.
func (c *MediaInfoAPIController) GetPostedPlaybackInfo(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	itemIdParam := params["itemId"]
	if itemIdParam == "" {
		c.errorHandler(w, r, &RequiredError{"itemId"}, nil)
		return
	}
	var userIdParam *string
	if query.Has("userId") {
		param := query.Get("userId")

		userIdParam = &param
	} else {
	}
	var maxStreamingBitrateParam *int32
	if query.Has("maxStreamingBitrate") {
		param, err := parseNumericParameter[int32](
			query.Get("maxStreamingBitrate"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		maxStreamingBitrateParam = &param
	} else {
	}
	var startTimeTicksParam *int64
	if query.Has("startTimeTicks") {
		param, err := parseNumericParameter[int64](
			query.Get("startTimeTicks"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		startTimeTicksParam = &param
	} else {
	}
	var audioStreamIndexParam *int32
	if query.Has("audioStreamIndex") {
		param, err := parseNumericParameter[int32](
			query.Get("audioStreamIndex"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		audioStreamIndexParam = &param
	} else {
	}
	var subtitleStreamIndexParam *int32
	if query.Has("subtitleStreamIndex") {
		param, err := parseNumericParameter[int32](
			query.Get("subtitleStreamIndex"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		subtitleStreamIndexParam = &param
	} else {
	}
	var maxAudioChannelsParam *int32
	if query.Has("maxAudioChannels") {
		param, err := parseNumericParameter[int32](
			query.Get("maxAudioChannels"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		maxAudioChannelsParam = &param
	} else {
	}
	var mediaSourceIdParam *string
	if query.Has("mediaSourceId") {
		param := query.Get("mediaSourceId")

		mediaSourceIdParam = &param
	} else {
	}
	var liveStreamIdParam *string
	if query.Has("liveStreamId") {
		param := query.Get("liveStreamId")

		liveStreamIdParam = &param
	} else {
	}
	var autoOpenLiveStreamParam *bool
	if query.Has("autoOpenLiveStream") {
		param, err := parseBoolParameter(
			query.Get("autoOpenLiveStream"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		autoOpenLiveStreamParam = &param
	} else {
	}
	var enableDirectPlayParam *bool
	if query.Has("enableDirectPlay") {
		param, err := parseBoolParameter(
			query.Get("enableDirectPlay"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		enableDirectPlayParam = &param
	} else {
	}
	var enableDirectStreamParam *bool
	if query.Has("enableDirectStream") {
		param, err := parseBoolParameter(
			query.Get("enableDirectStream"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		enableDirectStreamParam = &param
	} else {
	}
	var enableTranscodingParam *bool
	if query.Has("enableTranscoding") {
		param, err := parseBoolParameter(
			query.Get("enableTranscoding"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		enableTranscodingParam = &param
	} else {
	}
	var allowVideoStreamCopyParam *bool
	if query.Has("allowVideoStreamCopy") {
		param, err := parseBoolParameter(
			query.Get("allowVideoStreamCopy"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		allowVideoStreamCopyParam = &param
	} else {
	}
	var allowAudioStreamCopyParam *bool
	if query.Has("allowAudioStreamCopy") {
		param, err := parseBoolParameter(
			query.Get("allowAudioStreamCopy"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		allowAudioStreamCopyParam = &param
	} else {
	}
	playbackInfoDtoParam := PlaybackInfoDto{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&playbackInfoDtoParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertPlaybackInfoDtoRequired(playbackInfoDtoParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertPlaybackInfoDtoConstraints(playbackInfoDtoParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.GetPostedPlaybackInfo(r.Context(), itemIdParam, userIdParam, maxStreamingBitrateParam, startTimeTicksParam, audioStreamIndexParam, subtitleStreamIndexParam, maxAudioChannelsParam, mediaSourceIdParam, liveStreamIdParam, autoOpenLiveStreamParam, enableDirectPlayParam, enableDirectStreamParam, enableTranscodingParam, allowVideoStreamCopyParam, allowAudioStreamCopyParam, playbackInfoDtoParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// OpenLiveStream - Opens a media source.
func (c *MediaInfoAPIController) OpenLiveStream(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	var openTokenParam *string
	if query.Has("openToken") {
		param := query.Get("openToken")

		openTokenParam = &param
	} else {
	}
	var userIdParam *string
	if query.Has("userId") {
		param := query.Get("userId")

		userIdParam = &param
	} else {
	}
	var playSessionIdParam *string
	if query.Has("playSessionId") {
		param := query.Get("playSessionId")

		playSessionIdParam = &param
	} else {
	}
	var maxStreamingBitrateParam *int32
	if query.Has("maxStreamingBitrate") {
		param, err := parseNumericParameter[int32](
			query.Get("maxStreamingBitrate"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		maxStreamingBitrateParam = &param
	} else {
	}
	var startTimeTicksParam *int64
	if query.Has("startTimeTicks") {
		param, err := parseNumericParameter[int64](
			query.Get("startTimeTicks"),
			WithParse[int64](parseInt64),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		startTimeTicksParam = &param
	} else {
	}
	var audioStreamIndexParam *int32
	if query.Has("audioStreamIndex") {
		param, err := parseNumericParameter[int32](
			query.Get("audioStreamIndex"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		audioStreamIndexParam = &param
	} else {
	}
	var subtitleStreamIndexParam *int32
	if query.Has("subtitleStreamIndex") {
		param, err := parseNumericParameter[int32](
			query.Get("subtitleStreamIndex"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		subtitleStreamIndexParam = &param
	} else {
	}
	var maxAudioChannelsParam *int32
	if query.Has("maxAudioChannels") {
		param, err := parseNumericParameter[int32](
			query.Get("maxAudioChannels"),
			WithParse[int32](parseInt32),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		maxAudioChannelsParam = &param
	} else {
	}
	var itemIdParam *string
	if query.Has("itemId") {
		param := query.Get("itemId")

		itemIdParam = &param
	} else {
	}
	var enableDirectPlayParam *bool
	if query.Has("enableDirectPlay") {
		param, err := parseBoolParameter(
			query.Get("enableDirectPlay"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		enableDirectPlayParam = &param
	} else {
	}
	var enableDirectStreamParam *bool
	if query.Has("enableDirectStream") {
		param, err := parseBoolParameter(
			query.Get("enableDirectStream"),
			WithParse[bool](parseBool),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		enableDirectStreamParam = &param
	} else {
	}
	openLiveStreamDtoParam := OpenLiveStreamDto{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&openLiveStreamDtoParam); err != nil && !errors.Is(err, io.EOF) {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertOpenLiveStreamDtoRequired(openLiveStreamDtoParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertOpenLiveStreamDtoConstraints(openLiveStreamDtoParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.OpenLiveStream(r.Context(), openTokenParam, userIdParam, playSessionIdParam, maxStreamingBitrateParam, startTimeTicksParam, audioStreamIndexParam, subtitleStreamIndexParam, maxAudioChannelsParam, itemIdParam, enableDirectPlayParam, enableDirectStreamParam, openLiveStreamDtoParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}
