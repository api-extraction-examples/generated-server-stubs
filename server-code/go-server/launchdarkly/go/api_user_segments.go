/*
 * LaunchDarkly REST API
 *
 * Build custom integrations with the LaunchDarkly REST API
 *
 * API version: 5.3.0
 * Contact: support@launchdarkly.com
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"encoding/json"
	"net/http"
	"strings"

	"github.com/gorilla/mux"
)

// UserSegmentsAPIController binds http requests to an api service and writes the service results to the http response
type UserSegmentsAPIController struct {
	service UserSegmentsAPIServicer
	errorHandler ErrorHandler
}

// UserSegmentsAPIOption for how the controller is set up.
type UserSegmentsAPIOption func(*UserSegmentsAPIController)

// WithUserSegmentsAPIErrorHandler inject ErrorHandler into controller
func WithUserSegmentsAPIErrorHandler(h ErrorHandler) UserSegmentsAPIOption {
	return func(c *UserSegmentsAPIController) {
		c.errorHandler = h
	}
}

// NewUserSegmentsAPIController creates a default api controller
func NewUserSegmentsAPIController(s UserSegmentsAPIServicer, opts ...UserSegmentsAPIOption) Router {
	controller := &UserSegmentsAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the UserSegmentsAPIController
func (c *UserSegmentsAPIController) Routes() Routes {
	return Routes{
		"DeleteUserSegment": Route{
			strings.ToUpper("Delete"),
			"/api/v2/segments/{projectKey}/{environmentKey}/{userSegmentKey}",
			c.DeleteUserSegment,
		},
		"GetExpiringUserTargetsOnSegment": Route{
			strings.ToUpper("Get"),
			"/api/v2/segments/{projectKey}/{userSegmentKey}/expiring-user-targets/{environmentKey}",
			c.GetExpiringUserTargetsOnSegment,
		},
		"GetUserSegment": Route{
			strings.ToUpper("Get"),
			"/api/v2/segments/{projectKey}/{environmentKey}/{userSegmentKey}",
			c.GetUserSegment,
		},
		"GetUserSegments": Route{
			strings.ToUpper("Get"),
			"/api/v2/segments/{projectKey}/{environmentKey}",
			c.GetUserSegments,
		},
		"PatchExpiringUserTargetsOnSegment": Route{
			strings.ToUpper("Patch"),
			"/api/v2/segments/{projectKey}/{userSegmentKey}/expiring-user-targets/{environmentKey}",
			c.PatchExpiringUserTargetsOnSegment,
		},
		"PatchUserSegment": Route{
			strings.ToUpper("Patch"),
			"/api/v2/segments/{projectKey}/{environmentKey}/{userSegmentKey}",
			c.PatchUserSegment,
		},
		"PostUserSegment": Route{
			strings.ToUpper("Post"),
			"/api/v2/segments/{projectKey}/{environmentKey}",
			c.PostUserSegment,
		},
		"UpdateBigSegmentTargets": Route{
			strings.ToUpper("Post"),
			"/api/v2/segments/{projectKey}/{environmentKey}/{userSegmentKey}/users",
			c.UpdateBigSegmentTargets,
		},
	}
}

// DeleteUserSegment - Delete a user segment.
func (c *UserSegmentsAPIController) DeleteUserSegment(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	projectKeyParam := params["projectKey"]
	if projectKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"projectKey"}, nil)
		return
	}
	environmentKeyParam := params["environmentKey"]
	if environmentKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"environmentKey"}, nil)
		return
	}
	userSegmentKeyParam := params["userSegmentKey"]
	if userSegmentKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"userSegmentKey"}, nil)
		return
	}
	result, err := c.service.DeleteUserSegment(r.Context(), projectKeyParam, environmentKeyParam, userSegmentKeyParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetExpiringUserTargetsOnSegment - Get expiring user targets for user segment
func (c *UserSegmentsAPIController) GetExpiringUserTargetsOnSegment(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	projectKeyParam := params["projectKey"]
	if projectKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"projectKey"}, nil)
		return
	}
	environmentKeyParam := params["environmentKey"]
	if environmentKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"environmentKey"}, nil)
		return
	}
	userSegmentKeyParam := params["userSegmentKey"]
	if userSegmentKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"userSegmentKey"}, nil)
		return
	}
	result, err := c.service.GetExpiringUserTargetsOnSegment(r.Context(), projectKeyParam, environmentKeyParam, userSegmentKeyParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetUserSegment - Get a single user segment by key.
func (c *UserSegmentsAPIController) GetUserSegment(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	projectKeyParam := params["projectKey"]
	if projectKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"projectKey"}, nil)
		return
	}
	environmentKeyParam := params["environmentKey"]
	if environmentKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"environmentKey"}, nil)
		return
	}
	userSegmentKeyParam := params["userSegmentKey"]
	if userSegmentKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"userSegmentKey"}, nil)
		return
	}
	result, err := c.service.GetUserSegment(r.Context(), projectKeyParam, environmentKeyParam, userSegmentKeyParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// GetUserSegments - Get a list of all user segments in the given project.
func (c *UserSegmentsAPIController) GetUserSegments(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	projectKeyParam := params["projectKey"]
	if projectKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"projectKey"}, nil)
		return
	}
	environmentKeyParam := params["environmentKey"]
	if environmentKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"environmentKey"}, nil)
		return
	}
	var tagParam string
	if query.Has("tag") {
		param := query.Get("tag")

		tagParam = param
	} else {
	}
	result, err := c.service.GetUserSegments(r.Context(), projectKeyParam, environmentKeyParam, tagParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// PatchExpiringUserTargetsOnSegment - Update, add, or delete expiring user targets on user segment
func (c *UserSegmentsAPIController) PatchExpiringUserTargetsOnSegment(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	projectKeyParam := params["projectKey"]
	if projectKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"projectKey"}, nil)
		return
	}
	environmentKeyParam := params["environmentKey"]
	if environmentKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"environmentKey"}, nil)
		return
	}
	userSegmentKeyParam := params["userSegmentKey"]
	if userSegmentKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"userSegmentKey"}, nil)
		return
	}
	semanticPatchWithCommentParam := []SemanticPatchOperation{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&semanticPatchWithCommentParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	for _, el := range semanticPatchWithCommentParam {
		if err := AssertSemanticPatchOperationRequired(el); err != nil {
			c.errorHandler(w, r, err, nil)
			return
		}
	}
	result, err := c.service.PatchExpiringUserTargetsOnSegment(r.Context(), projectKeyParam, environmentKeyParam, userSegmentKeyParam, semanticPatchWithCommentParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// PatchUserSegment - Perform a partial update to a user segment.
func (c *UserSegmentsAPIController) PatchUserSegment(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	projectKeyParam := params["projectKey"]
	if projectKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"projectKey"}, nil)
		return
	}
	environmentKeyParam := params["environmentKey"]
	if environmentKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"environmentKey"}, nil)
		return
	}
	userSegmentKeyParam := params["userSegmentKey"]
	if userSegmentKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"userSegmentKey"}, nil)
		return
	}
	patchOnlyParam := []PatchOperation{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&patchOnlyParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	for _, el := range patchOnlyParam {
		if err := AssertPatchOperationRequired(el); err != nil {
			c.errorHandler(w, r, err, nil)
			return
		}
	}
	result, err := c.service.PatchUserSegment(r.Context(), projectKeyParam, environmentKeyParam, userSegmentKeyParam, patchOnlyParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// PostUserSegment - Creates a new user segment.
func (c *UserSegmentsAPIController) PostUserSegment(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	projectKeyParam := params["projectKey"]
	if projectKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"projectKey"}, nil)
		return
	}
	environmentKeyParam := params["environmentKey"]
	if environmentKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"environmentKey"}, nil)
		return
	}
	userSegmentBodyParam := PostUserSegmentRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&userSegmentBodyParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertPostUserSegmentRequestRequired(userSegmentBodyParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertPostUserSegmentRequestConstraints(userSegmentBodyParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.PostUserSegment(r.Context(), projectKeyParam, environmentKeyParam, userSegmentBodyParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// UpdateBigSegmentTargets - Update targets included or excluded in a big segment
func (c *UserSegmentsAPIController) UpdateBigSegmentTargets(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	projectKeyParam := params["projectKey"]
	if projectKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"projectKey"}, nil)
		return
	}
	environmentKeyParam := params["environmentKey"]
	if environmentKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"environmentKey"}, nil)
		return
	}
	userSegmentKeyParam := params["userSegmentKey"]
	if userSegmentKeyParam == "" {
		c.errorHandler(w, r, &RequiredError{"userSegmentKey"}, nil)
		return
	}
	bigSegmentTargetsBodyParam := UpdateBigSegmentTargetsRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&bigSegmentTargetsBodyParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertUpdateBigSegmentTargetsRequestRequired(bigSegmentTargetsBodyParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertUpdateBigSegmentTargetsRequestConstraints(bigSegmentTargetsBodyParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.UpdateBigSegmentTargets(r.Context(), projectKeyParam, environmentKeyParam, userSegmentKeyParam, bigSegmentTargetsBodyParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}
