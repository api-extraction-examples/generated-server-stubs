/*
 * App Store Connect API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * API version: 1.4.1
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package openapi

import (
	"encoding/json"
	"net/http"
	"strings"

	"github.com/gorilla/mux"
)

// BuildsAPIController binds http requests to an api service and writes the service results to the http response
type BuildsAPIController struct {
	service BuildsAPIServicer
	errorHandler ErrorHandler
}

// BuildsAPIOption for how the controller is set up.
type BuildsAPIOption func(*BuildsAPIController)

// WithBuildsAPIErrorHandler inject ErrorHandler into controller
func WithBuildsAPIErrorHandler(h ErrorHandler) BuildsAPIOption {
	return func(c *BuildsAPIController) {
		c.errorHandler = h
	}
}

// NewBuildsAPIController creates a default api controller
func NewBuildsAPIController(s BuildsAPIServicer, opts ...BuildsAPIOption) Router {
	controller := &BuildsAPIController{
		service:      s,
		errorHandler: DefaultErrorHandler,
	}

	for _, opt := range opts {
		opt(controller)
	}

	return controller
}

// Routes returns all the api routes for the BuildsAPIController
func (c *BuildsAPIController) Routes() Routes {
	return Routes{
		"BuildsAppEncryptionDeclarationGetToOneRelated": Route{
			strings.ToUpper("Get"),
			"/v1/builds/{id}/appEncryptionDeclaration",
			c.BuildsAppEncryptionDeclarationGetToOneRelated,
		},
		"BuildsAppEncryptionDeclarationGetToOneRelationship": Route{
			strings.ToUpper("Get"),
			"/v1/builds/{id}/relationships/appEncryptionDeclaration",
			c.BuildsAppEncryptionDeclarationGetToOneRelationship,
		},
		"BuildsAppEncryptionDeclarationUpdateToOneRelationship": Route{
			strings.ToUpper("Patch"),
			"/v1/builds/{id}/relationships/appEncryptionDeclaration",
			c.BuildsAppEncryptionDeclarationUpdateToOneRelationship,
		},
		"BuildsAppGetToOneRelated": Route{
			strings.ToUpper("Get"),
			"/v1/builds/{id}/app",
			c.BuildsAppGetToOneRelated,
		},
		"BuildsAppStoreVersionGetToOneRelated": Route{
			strings.ToUpper("Get"),
			"/v1/builds/{id}/appStoreVersion",
			c.BuildsAppStoreVersionGetToOneRelated,
		},
		"BuildsBetaAppReviewSubmissionGetToOneRelated": Route{
			strings.ToUpper("Get"),
			"/v1/builds/{id}/betaAppReviewSubmission",
			c.BuildsBetaAppReviewSubmissionGetToOneRelated,
		},
		"BuildsBetaBuildLocalizationsGetToManyRelated": Route{
			strings.ToUpper("Get"),
			"/v1/builds/{id}/betaBuildLocalizations",
			c.BuildsBetaBuildLocalizationsGetToManyRelated,
		},
		"BuildsBetaGroupsCreateToManyRelationship": Route{
			strings.ToUpper("Post"),
			"/v1/builds/{id}/relationships/betaGroups",
			c.BuildsBetaGroupsCreateToManyRelationship,
		},
		"BuildsBetaGroupsDeleteToManyRelationship": Route{
			strings.ToUpper("Delete"),
			"/v1/builds/{id}/relationships/betaGroups",
			c.BuildsBetaGroupsDeleteToManyRelationship,
		},
		"BuildsBuildBetaDetailGetToOneRelated": Route{
			strings.ToUpper("Get"),
			"/v1/builds/{id}/buildBetaDetail",
			c.BuildsBuildBetaDetailGetToOneRelated,
		},
		"BuildsDiagnosticSignaturesGetToManyRelated": Route{
			strings.ToUpper("Get"),
			"/v1/builds/{id}/diagnosticSignatures",
			c.BuildsDiagnosticSignaturesGetToManyRelated,
		},
		"BuildsGetCollection": Route{
			strings.ToUpper("Get"),
			"/v1/builds",
			c.BuildsGetCollection,
		},
		"BuildsGetInstance": Route{
			strings.ToUpper("Get"),
			"/v1/builds/{id}",
			c.BuildsGetInstance,
		},
		"BuildsIconsGetToManyRelated": Route{
			strings.ToUpper("Get"),
			"/v1/builds/{id}/icons",
			c.BuildsIconsGetToManyRelated,
		},
		"BuildsIndividualTestersCreateToManyRelationship": Route{
			strings.ToUpper("Post"),
			"/v1/builds/{id}/relationships/individualTesters",
			c.BuildsIndividualTestersCreateToManyRelationship,
		},
		"BuildsIndividualTestersDeleteToManyRelationship": Route{
			strings.ToUpper("Delete"),
			"/v1/builds/{id}/relationships/individualTesters",
			c.BuildsIndividualTestersDeleteToManyRelationship,
		},
		"BuildsIndividualTestersGetToManyRelated": Route{
			strings.ToUpper("Get"),
			"/v1/builds/{id}/individualTesters",
			c.BuildsIndividualTestersGetToManyRelated,
		},
		"BuildsIndividualTestersGetToManyRelationship": Route{
			strings.ToUpper("Get"),
			"/v1/builds/{id}/relationships/individualTesters",
			c.BuildsIndividualTestersGetToManyRelationship,
		},
		"BuildsPerfPowerMetricsGetToManyRelated": Route{
			strings.ToUpper("Get"),
			"/v1/builds/{id}/perfPowerMetrics",
			c.BuildsPerfPowerMetricsGetToManyRelated,
		},
		"BuildsPreReleaseVersionGetToOneRelated": Route{
			strings.ToUpper("Get"),
			"/v1/builds/{id}/preReleaseVersion",
			c.BuildsPreReleaseVersionGetToOneRelated,
		},
		"BuildsUpdateInstance": Route{
			strings.ToUpper("Patch"),
			"/v1/builds/{id}",
			c.BuildsUpdateInstance,
		},
	}
}

// BuildsAppEncryptionDeclarationGetToOneRelated - 
func (c *BuildsAPIController) BuildsAppEncryptionDeclarationGetToOneRelated(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var fieldsAppEncryptionDeclarationsParam []string
	if query.Has("fields[appEncryptionDeclarations]") {
		fieldsAppEncryptionDeclarationsParam = strings.Split(query.Get("fields[appEncryptionDeclarations]"), ",")
	}
	result, err := c.service.BuildsAppEncryptionDeclarationGetToOneRelated(r.Context(), idParam, fieldsAppEncryptionDeclarationsParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsAppEncryptionDeclarationGetToOneRelationship - 
func (c *BuildsAPIController) BuildsAppEncryptionDeclarationGetToOneRelationship(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	result, err := c.service.BuildsAppEncryptionDeclarationGetToOneRelationship(r.Context(), idParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsAppEncryptionDeclarationUpdateToOneRelationship - 
func (c *BuildsAPIController) BuildsAppEncryptionDeclarationUpdateToOneRelationship(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	buildAppEncryptionDeclarationLinkageRequestParam := BuildAppEncryptionDeclarationLinkageRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&buildAppEncryptionDeclarationLinkageRequestParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertBuildAppEncryptionDeclarationLinkageRequestRequired(buildAppEncryptionDeclarationLinkageRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertBuildAppEncryptionDeclarationLinkageRequestConstraints(buildAppEncryptionDeclarationLinkageRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.BuildsAppEncryptionDeclarationUpdateToOneRelationship(r.Context(), idParam, buildAppEncryptionDeclarationLinkageRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsAppGetToOneRelated - 
func (c *BuildsAPIController) BuildsAppGetToOneRelated(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var fieldsAppsParam []string
	if query.Has("fields[apps]") {
		fieldsAppsParam = strings.Split(query.Get("fields[apps]"), ",")
	}
	result, err := c.service.BuildsAppGetToOneRelated(r.Context(), idParam, fieldsAppsParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsAppStoreVersionGetToOneRelated - 
func (c *BuildsAPIController) BuildsAppStoreVersionGetToOneRelated(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var fieldsAppStoreVersionsParam []string
	if query.Has("fields[appStoreVersions]") {
		fieldsAppStoreVersionsParam = strings.Split(query.Get("fields[appStoreVersions]"), ",")
	}
	result, err := c.service.BuildsAppStoreVersionGetToOneRelated(r.Context(), idParam, fieldsAppStoreVersionsParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsBetaAppReviewSubmissionGetToOneRelated - 
func (c *BuildsAPIController) BuildsBetaAppReviewSubmissionGetToOneRelated(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var fieldsBetaAppReviewSubmissionsParam []string
	if query.Has("fields[betaAppReviewSubmissions]") {
		fieldsBetaAppReviewSubmissionsParam = strings.Split(query.Get("fields[betaAppReviewSubmissions]"), ",")
	}
	result, err := c.service.BuildsBetaAppReviewSubmissionGetToOneRelated(r.Context(), idParam, fieldsBetaAppReviewSubmissionsParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsBetaBuildLocalizationsGetToManyRelated - 
func (c *BuildsAPIController) BuildsBetaBuildLocalizationsGetToManyRelated(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var fieldsBetaBuildLocalizationsParam []string
	if query.Has("fields[betaBuildLocalizations]") {
		fieldsBetaBuildLocalizationsParam = strings.Split(query.Get("fields[betaBuildLocalizations]"), ",")
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMaximum[int32](200),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	result, err := c.service.BuildsBetaBuildLocalizationsGetToManyRelated(r.Context(), idParam, fieldsBetaBuildLocalizationsParam, limitParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsBetaGroupsCreateToManyRelationship - 
func (c *BuildsAPIController) BuildsBetaGroupsCreateToManyRelationship(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	buildBetaGroupsLinkagesRequestParam := BuildBetaGroupsLinkagesRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&buildBetaGroupsLinkagesRequestParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertBuildBetaGroupsLinkagesRequestRequired(buildBetaGroupsLinkagesRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertBuildBetaGroupsLinkagesRequestConstraints(buildBetaGroupsLinkagesRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.BuildsBetaGroupsCreateToManyRelationship(r.Context(), idParam, buildBetaGroupsLinkagesRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsBetaGroupsDeleteToManyRelationship - 
func (c *BuildsAPIController) BuildsBetaGroupsDeleteToManyRelationship(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	buildBetaGroupsLinkagesRequestParam := BuildBetaGroupsLinkagesRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&buildBetaGroupsLinkagesRequestParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertBuildBetaGroupsLinkagesRequestRequired(buildBetaGroupsLinkagesRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertBuildBetaGroupsLinkagesRequestConstraints(buildBetaGroupsLinkagesRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.BuildsBetaGroupsDeleteToManyRelationship(r.Context(), idParam, buildBetaGroupsLinkagesRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsBuildBetaDetailGetToOneRelated - 
func (c *BuildsAPIController) BuildsBuildBetaDetailGetToOneRelated(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var fieldsBuildBetaDetailsParam []string
	if query.Has("fields[buildBetaDetails]") {
		fieldsBuildBetaDetailsParam = strings.Split(query.Get("fields[buildBetaDetails]"), ",")
	}
	result, err := c.service.BuildsBuildBetaDetailGetToOneRelated(r.Context(), idParam, fieldsBuildBetaDetailsParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsDiagnosticSignaturesGetToManyRelated - 
func (c *BuildsAPIController) BuildsDiagnosticSignaturesGetToManyRelated(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var filterDiagnosticTypeParam []string
	if query.Has("filter[diagnosticType]") {
		filterDiagnosticTypeParam = strings.Split(query.Get("filter[diagnosticType]"), ",")
	}
	var fieldsDiagnosticSignaturesParam []string
	if query.Has("fields[diagnosticSignatures]") {
		fieldsDiagnosticSignaturesParam = strings.Split(query.Get("fields[diagnosticSignatures]"), ",")
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMaximum[int32](200),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	result, err := c.service.BuildsDiagnosticSignaturesGetToManyRelated(r.Context(), idParam, filterDiagnosticTypeParam, fieldsDiagnosticSignaturesParam, limitParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsGetCollection - 
func (c *BuildsAPIController) BuildsGetCollection(w http.ResponseWriter, r *http.Request) {
	query := r.URL.Query()
	var filterBetaAppReviewSubmissionBetaReviewStateParam []string
	if query.Has("filter[betaAppReviewSubmission.betaReviewState]") {
		filterBetaAppReviewSubmissionBetaReviewStateParam = strings.Split(query.Get("filter[betaAppReviewSubmission.betaReviewState]"), ",")
	}
	var filterExpiredParam []string
	if query.Has("filter[expired]") {
		filterExpiredParam = strings.Split(query.Get("filter[expired]"), ",")
	}
	var filterPreReleaseVersionPlatformParam []string
	if query.Has("filter[preReleaseVersion.platform]") {
		filterPreReleaseVersionPlatformParam = strings.Split(query.Get("filter[preReleaseVersion.platform]"), ",")
	}
	var filterPreReleaseVersionVersionParam []string
	if query.Has("filter[preReleaseVersion.version]") {
		filterPreReleaseVersionVersionParam = strings.Split(query.Get("filter[preReleaseVersion.version]"), ",")
	}
	var filterProcessingStateParam []string
	if query.Has("filter[processingState]") {
		filterProcessingStateParam = strings.Split(query.Get("filter[processingState]"), ",")
	}
	var filterUsesNonExemptEncryptionParam []string
	if query.Has("filter[usesNonExemptEncryption]") {
		filterUsesNonExemptEncryptionParam = strings.Split(query.Get("filter[usesNonExemptEncryption]"), ",")
	}
	var filterVersionParam []string
	if query.Has("filter[version]") {
		filterVersionParam = strings.Split(query.Get("filter[version]"), ",")
	}
	var filterAppParam []string
	if query.Has("filter[app]") {
		filterAppParam = strings.Split(query.Get("filter[app]"), ",")
	}
	var filterAppStoreVersionParam []string
	if query.Has("filter[appStoreVersion]") {
		filterAppStoreVersionParam = strings.Split(query.Get("filter[appStoreVersion]"), ",")
	}
	var filterBetaGroupsParam []string
	if query.Has("filter[betaGroups]") {
		filterBetaGroupsParam = strings.Split(query.Get("filter[betaGroups]"), ",")
	}
	var filterPreReleaseVersionParam []string
	if query.Has("filter[preReleaseVersion]") {
		filterPreReleaseVersionParam = strings.Split(query.Get("filter[preReleaseVersion]"), ",")
	}
	var filterIdParam []string
	if query.Has("filter[id]") {
		filterIdParam = strings.Split(query.Get("filter[id]"), ",")
	}
	var sortParam []string
	if query.Has("sort") {
		sortParam = strings.Split(query.Get("sort"), ",")
	}
	var fieldsBuildsParam []string
	if query.Has("fields[builds]") {
		fieldsBuildsParam = strings.Split(query.Get("fields[builds]"), ",")
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMaximum[int32](200),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	var includeParam []string
	if query.Has("include") {
		includeParam = strings.Split(query.Get("include"), ",")
	}
	var fieldsAppEncryptionDeclarationsParam []string
	if query.Has("fields[appEncryptionDeclarations]") {
		fieldsAppEncryptionDeclarationsParam = strings.Split(query.Get("fields[appEncryptionDeclarations]"), ",")
	}
	var fieldsBetaAppReviewSubmissionsParam []string
	if query.Has("fields[betaAppReviewSubmissions]") {
		fieldsBetaAppReviewSubmissionsParam = strings.Split(query.Get("fields[betaAppReviewSubmissions]"), ",")
	}
	var fieldsBuildBetaDetailsParam []string
	if query.Has("fields[buildBetaDetails]") {
		fieldsBuildBetaDetailsParam = strings.Split(query.Get("fields[buildBetaDetails]"), ",")
	}
	var fieldsBuildIconsParam []string
	if query.Has("fields[buildIcons]") {
		fieldsBuildIconsParam = strings.Split(query.Get("fields[buildIcons]"), ",")
	}
	var fieldsPerfPowerMetricsParam []string
	if query.Has("fields[perfPowerMetrics]") {
		fieldsPerfPowerMetricsParam = strings.Split(query.Get("fields[perfPowerMetrics]"), ",")
	}
	var fieldsPreReleaseVersionsParam []string
	if query.Has("fields[preReleaseVersions]") {
		fieldsPreReleaseVersionsParam = strings.Split(query.Get("fields[preReleaseVersions]"), ",")
	}
	var fieldsAppStoreVersionsParam []string
	if query.Has("fields[appStoreVersions]") {
		fieldsAppStoreVersionsParam = strings.Split(query.Get("fields[appStoreVersions]"), ",")
	}
	var fieldsDiagnosticSignaturesParam []string
	if query.Has("fields[diagnosticSignatures]") {
		fieldsDiagnosticSignaturesParam = strings.Split(query.Get("fields[diagnosticSignatures]"), ",")
	}
	var fieldsBetaTestersParam []string
	if query.Has("fields[betaTesters]") {
		fieldsBetaTestersParam = strings.Split(query.Get("fields[betaTesters]"), ",")
	}
	var fieldsBetaBuildLocalizationsParam []string
	if query.Has("fields[betaBuildLocalizations]") {
		fieldsBetaBuildLocalizationsParam = strings.Split(query.Get("fields[betaBuildLocalizations]"), ",")
	}
	var fieldsAppsParam []string
	if query.Has("fields[apps]") {
		fieldsAppsParam = strings.Split(query.Get("fields[apps]"), ",")
	}
	var limitBetaBuildLocalizationsParam int32
	if query.Has("limit[betaBuildLocalizations]") {
		param, err := parseNumericParameter[int32](
			query.Get("limit[betaBuildLocalizations]"),
			WithParse[int32](parseInt32),
			WithMaximum[int32](50),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitBetaBuildLocalizationsParam = param
	} else {
	}
	var limitIconsParam int32
	if query.Has("limit[icons]") {
		param, err := parseNumericParameter[int32](
			query.Get("limit[icons]"),
			WithParse[int32](parseInt32),
			WithMaximum[int32](50),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitIconsParam = param
	} else {
	}
	var limitIndividualTestersParam int32
	if query.Has("limit[individualTesters]") {
		param, err := parseNumericParameter[int32](
			query.Get("limit[individualTesters]"),
			WithParse[int32](parseInt32),
			WithMaximum[int32](50),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitIndividualTestersParam = param
	} else {
	}
	result, err := c.service.BuildsGetCollection(r.Context(), filterBetaAppReviewSubmissionBetaReviewStateParam, filterExpiredParam, filterPreReleaseVersionPlatformParam, filterPreReleaseVersionVersionParam, filterProcessingStateParam, filterUsesNonExemptEncryptionParam, filterVersionParam, filterAppParam, filterAppStoreVersionParam, filterBetaGroupsParam, filterPreReleaseVersionParam, filterIdParam, sortParam, fieldsBuildsParam, limitParam, includeParam, fieldsAppEncryptionDeclarationsParam, fieldsBetaAppReviewSubmissionsParam, fieldsBuildBetaDetailsParam, fieldsBuildIconsParam, fieldsPerfPowerMetricsParam, fieldsPreReleaseVersionsParam, fieldsAppStoreVersionsParam, fieldsDiagnosticSignaturesParam, fieldsBetaTestersParam, fieldsBetaBuildLocalizationsParam, fieldsAppsParam, limitBetaBuildLocalizationsParam, limitIconsParam, limitIndividualTestersParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsGetInstance - 
func (c *BuildsAPIController) BuildsGetInstance(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var fieldsBuildsParam []string
	if query.Has("fields[builds]") {
		fieldsBuildsParam = strings.Split(query.Get("fields[builds]"), ",")
	}
	var includeParam []string
	if query.Has("include") {
		includeParam = strings.Split(query.Get("include"), ",")
	}
	var fieldsAppEncryptionDeclarationsParam []string
	if query.Has("fields[appEncryptionDeclarations]") {
		fieldsAppEncryptionDeclarationsParam = strings.Split(query.Get("fields[appEncryptionDeclarations]"), ",")
	}
	var fieldsBetaAppReviewSubmissionsParam []string
	if query.Has("fields[betaAppReviewSubmissions]") {
		fieldsBetaAppReviewSubmissionsParam = strings.Split(query.Get("fields[betaAppReviewSubmissions]"), ",")
	}
	var fieldsBuildBetaDetailsParam []string
	if query.Has("fields[buildBetaDetails]") {
		fieldsBuildBetaDetailsParam = strings.Split(query.Get("fields[buildBetaDetails]"), ",")
	}
	var fieldsBuildIconsParam []string
	if query.Has("fields[buildIcons]") {
		fieldsBuildIconsParam = strings.Split(query.Get("fields[buildIcons]"), ",")
	}
	var fieldsPerfPowerMetricsParam []string
	if query.Has("fields[perfPowerMetrics]") {
		fieldsPerfPowerMetricsParam = strings.Split(query.Get("fields[perfPowerMetrics]"), ",")
	}
	var fieldsPreReleaseVersionsParam []string
	if query.Has("fields[preReleaseVersions]") {
		fieldsPreReleaseVersionsParam = strings.Split(query.Get("fields[preReleaseVersions]"), ",")
	}
	var fieldsAppStoreVersionsParam []string
	if query.Has("fields[appStoreVersions]") {
		fieldsAppStoreVersionsParam = strings.Split(query.Get("fields[appStoreVersions]"), ",")
	}
	var fieldsDiagnosticSignaturesParam []string
	if query.Has("fields[diagnosticSignatures]") {
		fieldsDiagnosticSignaturesParam = strings.Split(query.Get("fields[diagnosticSignatures]"), ",")
	}
	var fieldsBetaTestersParam []string
	if query.Has("fields[betaTesters]") {
		fieldsBetaTestersParam = strings.Split(query.Get("fields[betaTesters]"), ",")
	}
	var fieldsBetaBuildLocalizationsParam []string
	if query.Has("fields[betaBuildLocalizations]") {
		fieldsBetaBuildLocalizationsParam = strings.Split(query.Get("fields[betaBuildLocalizations]"), ",")
	}
	var fieldsAppsParam []string
	if query.Has("fields[apps]") {
		fieldsAppsParam = strings.Split(query.Get("fields[apps]"), ",")
	}
	var limitBetaBuildLocalizationsParam int32
	if query.Has("limit[betaBuildLocalizations]") {
		param, err := parseNumericParameter[int32](
			query.Get("limit[betaBuildLocalizations]"),
			WithParse[int32](parseInt32),
			WithMaximum[int32](50),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitBetaBuildLocalizationsParam = param
	} else {
	}
	var limitIconsParam int32
	if query.Has("limit[icons]") {
		param, err := parseNumericParameter[int32](
			query.Get("limit[icons]"),
			WithParse[int32](parseInt32),
			WithMaximum[int32](50),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitIconsParam = param
	} else {
	}
	var limitIndividualTestersParam int32
	if query.Has("limit[individualTesters]") {
		param, err := parseNumericParameter[int32](
			query.Get("limit[individualTesters]"),
			WithParse[int32](parseInt32),
			WithMaximum[int32](50),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitIndividualTestersParam = param
	} else {
	}
	result, err := c.service.BuildsGetInstance(r.Context(), idParam, fieldsBuildsParam, includeParam, fieldsAppEncryptionDeclarationsParam, fieldsBetaAppReviewSubmissionsParam, fieldsBuildBetaDetailsParam, fieldsBuildIconsParam, fieldsPerfPowerMetricsParam, fieldsPreReleaseVersionsParam, fieldsAppStoreVersionsParam, fieldsDiagnosticSignaturesParam, fieldsBetaTestersParam, fieldsBetaBuildLocalizationsParam, fieldsAppsParam, limitBetaBuildLocalizationsParam, limitIconsParam, limitIndividualTestersParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsIconsGetToManyRelated - 
func (c *BuildsAPIController) BuildsIconsGetToManyRelated(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var fieldsBuildIconsParam []string
	if query.Has("fields[buildIcons]") {
		fieldsBuildIconsParam = strings.Split(query.Get("fields[buildIcons]"), ",")
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMaximum[int32](200),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	result, err := c.service.BuildsIconsGetToManyRelated(r.Context(), idParam, fieldsBuildIconsParam, limitParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsIndividualTestersCreateToManyRelationship - 
func (c *BuildsAPIController) BuildsIndividualTestersCreateToManyRelationship(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	buildIndividualTestersLinkagesRequestParam := BuildIndividualTestersLinkagesRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&buildIndividualTestersLinkagesRequestParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertBuildIndividualTestersLinkagesRequestRequired(buildIndividualTestersLinkagesRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertBuildIndividualTestersLinkagesRequestConstraints(buildIndividualTestersLinkagesRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.BuildsIndividualTestersCreateToManyRelationship(r.Context(), idParam, buildIndividualTestersLinkagesRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsIndividualTestersDeleteToManyRelationship - 
func (c *BuildsAPIController) BuildsIndividualTestersDeleteToManyRelationship(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	buildIndividualTestersLinkagesRequestParam := BuildIndividualTestersLinkagesRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&buildIndividualTestersLinkagesRequestParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertBuildIndividualTestersLinkagesRequestRequired(buildIndividualTestersLinkagesRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertBuildIndividualTestersLinkagesRequestConstraints(buildIndividualTestersLinkagesRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.BuildsIndividualTestersDeleteToManyRelationship(r.Context(), idParam, buildIndividualTestersLinkagesRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsIndividualTestersGetToManyRelated - 
func (c *BuildsAPIController) BuildsIndividualTestersGetToManyRelated(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var fieldsBetaTestersParam []string
	if query.Has("fields[betaTesters]") {
		fieldsBetaTestersParam = strings.Split(query.Get("fields[betaTesters]"), ",")
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMaximum[int32](200),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	result, err := c.service.BuildsIndividualTestersGetToManyRelated(r.Context(), idParam, fieldsBetaTestersParam, limitParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsIndividualTestersGetToManyRelationship - 
func (c *BuildsAPIController) BuildsIndividualTestersGetToManyRelationship(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var limitParam int32
	if query.Has("limit") {
		param, err := parseNumericParameter[int32](
			query.Get("limit"),
			WithParse[int32](parseInt32),
			WithMaximum[int32](200),
		)
		if err != nil {
			c.errorHandler(w, r, &ParsingError{Err: err}, nil)
			return
		}

		limitParam = param
	} else {
	}
	result, err := c.service.BuildsIndividualTestersGetToManyRelationship(r.Context(), idParam, limitParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsPerfPowerMetricsGetToManyRelated - 
func (c *BuildsAPIController) BuildsPerfPowerMetricsGetToManyRelated(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var filterDeviceTypeParam []string
	if query.Has("filter[deviceType]") {
		filterDeviceTypeParam = strings.Split(query.Get("filter[deviceType]"), ",")
	}
	var filterMetricTypeParam []string
	if query.Has("filter[metricType]") {
		filterMetricTypeParam = strings.Split(query.Get("filter[metricType]"), ",")
	}
	var filterPlatformParam []string
	if query.Has("filter[platform]") {
		filterPlatformParam = strings.Split(query.Get("filter[platform]"), ",")
	}
	result, err := c.service.BuildsPerfPowerMetricsGetToManyRelated(r.Context(), idParam, filterDeviceTypeParam, filterMetricTypeParam, filterPlatformParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsPreReleaseVersionGetToOneRelated - 
func (c *BuildsAPIController) BuildsPreReleaseVersionGetToOneRelated(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	query := r.URL.Query()
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	var fieldsPreReleaseVersionsParam []string
	if query.Has("fields[preReleaseVersions]") {
		fieldsPreReleaseVersionsParam = strings.Split(query.Get("fields[preReleaseVersions]"), ",")
	}
	result, err := c.service.BuildsPreReleaseVersionGetToOneRelated(r.Context(), idParam, fieldsPreReleaseVersionsParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}

// BuildsUpdateInstance - 
func (c *BuildsAPIController) BuildsUpdateInstance(w http.ResponseWriter, r *http.Request) {
	params := mux.Vars(r)
	idParam := params["id"]
	if idParam == "" {
		c.errorHandler(w, r, &RequiredError{"id"}, nil)
		return
	}
	buildUpdateRequestParam := BuildUpdateRequest{}
	d := json.NewDecoder(r.Body)
	d.DisallowUnknownFields()
	if err := d.Decode(&buildUpdateRequestParam); err != nil {
		c.errorHandler(w, r, &ParsingError{Err: err}, nil)
		return
	}
	if err := AssertBuildUpdateRequestRequired(buildUpdateRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	if err := AssertBuildUpdateRequestConstraints(buildUpdateRequestParam); err != nil {
		c.errorHandler(w, r, err, nil)
		return
	}
	result, err := c.service.BuildsUpdateInstance(r.Context(), idParam, buildUpdateRequestParam)
	// If an error occurred, encode the error with the status code
	if err != nil {
		c.errorHandler(w, r, err, &result)
		return
	}
	// If no error, encode the body and the result code
	EncodeJSONResponse(result.Body, &result.Code, w)
}
