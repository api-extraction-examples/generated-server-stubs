/*
 * Open Build Service API
 *
 * The _Open Build Service API_ is a XML API.  To authenticate, use [HTTP basic authentication](https://en.wikipedia.org/wiki/Basic_access_authentication) by passing the _Authorization_ header in the form of `Authorization: Basic <credentials>`.  There is no API versioning as there is no need for it right now.  Only rudimentary rate limiting is implemented, so please be gentle when using the API concurrently, especially with potentially expensive operations. In case of abuse, we will limit/remove your access.  For command-line users, we recommend using [osc](https://github.com/openSUSE/osc) with its _api_ command to interact with the API. It's as simple as this example: `osc api /about` (_about_ is one of the endpoints documented below) 
 *
 * The version of the OpenAPI document: 2.10.50
 * 
 * Generated by: https://openapi-generator.tech
 */

using System;
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Http;
using Swashbuckle.AspNetCore.Annotations;
using Swashbuckle.AspNetCore.SwaggerGen;
using Newtonsoft.Json;
using Org.OpenAPITools.Attributes;
using Org.OpenAPITools.Models;

namespace Org.OpenAPITools.Controllers
{ 
    /// <summary>
    /// 
    /// </summary>
    [ApiController]
    public class AttributeNamespacesApiController : ControllerBase
    { 
        /// <summary>
        /// List all attribute namespaces.
        /// </summary>
        /// <remarks>List all attribute namespaces.</remarks>
        /// <response code="200">OK. The request has succeeded.  XML Schema used for body validation: [directory.xsd](../schema/directory.xsd) </response>
        /// <response code="401"></response>
        [HttpGet]
        [Route("/attribute")]
        [ValidateModelState]
        [SwaggerOperation("AttributeGet")]
        [SwaggerResponse(statusCode: 200, type: typeof(Object), description: "OK. The request has succeeded.  XML Schema used for body validation: [directory.xsd](../schema/directory.xsd) ")]
        public virtual IActionResult AttributeGet()
        {

            //TODO: Uncomment the next line to return response 200 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(200, default(Object));
            //TODO: Uncomment the next line to return response 401 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(401);
            string exampleJson = null;
            exampleJson = "Custom MIME type example not yet supported: application/xml; charset=utf-8";
            
            var example = exampleJson != null
            ? JsonConvert.DeserializeObject<Object>(exampleJson)
            : default(Object);
            //TODO: Change the data returned
            return new ObjectResult(example);
        }

        /// <summary>
        /// Delete an attribute namespace and all attributes below.
        /// </summary>
        /// <remarks>Delete an attribute namespace and all attributes below.  This operation is the same as the one defined with [DELETE /attribute/{namespace}/_meta](#/Attributes/delete_attribute__namespace___meta). </remarks>
        /// <response code="200">OK. The request has succeeded.  XML Schema used for body validation: [status.xsd](../schema/status.xsd) </response>
        /// <response code="401"></response>
        [HttpDelete]
        [Route("/attribute/{namespace}")]
        [ValidateModelState]
        [SwaggerOperation("AttributeNamespaceDelete")]
        [SwaggerResponse(statusCode: 200, type: typeof(Object), description: "OK. The request has succeeded.  XML Schema used for body validation: [status.xsd](../schema/status.xsd) ")]
        public virtual IActionResult AttributeNamespaceDelete()
        {

            //TODO: Uncomment the next line to return response 200 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(200, default(Object));
            //TODO: Uncomment the next line to return response 401 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(401);
            string exampleJson = null;
            exampleJson = "Custom MIME type example not yet supported: application/xml; charset=utf-8";
            
            var example = exampleJson != null
            ? JsonConvert.DeserializeObject<Object>(exampleJson)
            : default(Object);
            //TODO: Change the data returned
            return new ObjectResult(example);
        }

        /// <summary>
        /// List all attributes below a namespace.
        /// </summary>
        /// <remarks>List all attributes under a given attribute namespace.</remarks>
        /// <param name="varNamespace">The namespace</param>
        /// <response code="200">OK. The request has succeeded.  XML Schema used for body validation: [directory.xsd](../schema/directory.xsd) </response>
        /// <response code="401"></response>
        /// <response code="404">Not Found.</response>
        [HttpGet]
        [Route("/attribute/{namespace}")]
        [ValidateModelState]
        [SwaggerOperation("AttributeNamespaceGet")]
        [SwaggerResponse(statusCode: 200, type: typeof(Object), description: "OK. The request has succeeded.  XML Schema used for body validation: [directory.xsd](../schema/directory.xsd) ")]
        [SwaggerResponse(statusCode: 404, type: typeof(Object), description: "Not Found.")]
        public virtual IActionResult AttributeNamespaceGet([FromRoute (Name = "namespace")][Required]string varNamespace)
        {

            //TODO: Uncomment the next line to return response 200 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(200, default(Object));
            //TODO: Uncomment the next line to return response 401 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(401);
            //TODO: Uncomment the next line to return response 404 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(404, default(Object));
            string exampleJson = null;
            exampleJson = "Custom MIME type example not yet supported: application/xml; charset=utf-8";
            
            var example = exampleJson != null
            ? JsonConvert.DeserializeObject<Object>(exampleJson)
            : default(Object);
            //TODO: Change the data returned
            return new ObjectResult(example);
        }

        /// <summary>
        /// Delete an attribute namespace and all attributes below.
        /// </summary>
        /// <remarks>Delete an attribute namespace and all attributes below.  This operation is the same as the one defined with [DELETE /attribute/{namespace}](#/Attributes/delete_attribute__namespace_). </remarks>
        /// <response code="200"></response>
        /// <response code="401"></response>
        [HttpDelete]
        [Route("/attribute/{namespace}/_meta")]
        [ValidateModelState]
        [SwaggerOperation("AttributeNamespaceMetaDelete")]
        public virtual IActionResult AttributeNamespaceMetaDelete()
        {

            //TODO: Uncomment the next line to return response 200 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(200);
            //TODO: Uncomment the next line to return response 401 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(401);

            throw new NotImplementedException();
        }

        /// <summary>
        /// Show attribute namespace.
        /// </summary>
        /// <remarks>Shows attribute namespace.</remarks>
        /// <response code="200">OK. The request has succeeded.  XML Schema used for body validation: [attribute_namespace_meta.xsd](../schema/attribute_namespace_meta.xsd) </response>
        /// <response code="401"></response>
        /// <response code="404">Not Found.</response>
        [HttpGet]
        [Route("/attribute/{namespace}/_meta")]
        [ValidateModelState]
        [SwaggerOperation("AttributeNamespaceMetaGet")]
        [SwaggerResponse(statusCode: 200, type: typeof(AttributeNamespaceMetaGet200Response), description: "OK. The request has succeeded.  XML Schema used for body validation: [attribute_namespace_meta.xsd](../schema/attribute_namespace_meta.xsd) ")]
        [SwaggerResponse(statusCode: 404, type: typeof(Object), description: "Not Found.")]
        public virtual IActionResult AttributeNamespaceMetaGet()
        {

            //TODO: Uncomment the next line to return response 200 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(200, default(AttributeNamespaceMetaGet200Response));
            //TODO: Uncomment the next line to return response 401 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(401);
            //TODO: Uncomment the next line to return response 404 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(404, default(Object));
            string exampleJson = null;
            exampleJson = "<namespace name=\"OBS_TEST\">\n</namespace>";
            
            var example = exampleJson != null
            ? JsonConvert.DeserializeObject<AttributeNamespaceMetaGet200Response>(exampleJson)
            : default(AttributeNamespaceMetaGet200Response);
            //TODO: Change the data returned
            return new ObjectResult(example);
        }

        /// <summary>
        /// Change attribute namespace. Create an attribute namespace if it doesn&#39;t exist.
        /// </summary>
        /// <remarks>This endpoint can be used for both, creating an attribute namespace and updating it:   * If the attribute namespace passed as parameter doesn&#39;t exist, it will create the attribute namespace.   * If the attribute namespace passed as parameter already exists, it will update the namespace attribute.  This operation is the same as the one defined with [PUT](#/Attributes/put_attribute__namespace___meta). </remarks>
        /// <param name="body">Attribute namespace definition.  XML Schema used for body validation: [attribute_namespace_meta.xsd](../schema/attribute_namespace_meta.xsd) </param>
        /// <response code="200"></response>
        /// <response code="400">Validation Failed.</response>
        /// <response code="401"></response>
        /// <response code="404">Not Found.</response>
        [HttpPost]
        [Route("/attribute/{namespace}/_meta")]
        [Consumes("application/xml; charset=utf-8")]
        [ValidateModelState]
        [SwaggerOperation("AttributeNamespaceMetaPost")]
        [SwaggerResponse(statusCode: 400, type: typeof(Object), description: "Validation Failed.")]
        [SwaggerResponse(statusCode: 404, type: typeof(Object), description: "Not Found.")]
        public virtual IActionResult AttributeNamespaceMetaPost([FromBody]Object body)
        {

            //TODO: Uncomment the next line to return response 200 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(200);
            //TODO: Uncomment the next line to return response 400 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(400, default(Object));
            //TODO: Uncomment the next line to return response 401 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(401);
            //TODO: Uncomment the next line to return response 404 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(404, default(Object));

            throw new NotImplementedException();
        }

        /// <summary>
        /// Change attribute namespace. Create an attribute namespace if it doesn&#39;t exist.
        /// </summary>
        /// <remarks>This endpoint can be used for both, creating an attribute namespace and updating it:   * If the attribute namespace passed as parameter doesn&#39;t exist, it will create the attribute namespace.   * If the attribute namespace passed as parameter already exists, it will update the namespace attribute.  This operation is the same as the one defined with [POST](#/Attributes/post_attribute__namespace___meta). </remarks>
        /// <param name="body">Attribute namespace definition.  XML Schema used for body validation: [attribute_namespace_meta.xsd](../schema/attribute_namespace_meta.xsd) </param>
        /// <response code="200"></response>
        /// <response code="400">Validation Failed.</response>
        /// <response code="401"></response>
        /// <response code="404">Not Found.</response>
        [HttpPut]
        [Route("/attribute/{namespace}/_meta")]
        [Consumes("application/xml; charset=utf-8")]
        [ValidateModelState]
        [SwaggerOperation("AttributeNamespaceMetaPut")]
        [SwaggerResponse(statusCode: 400, type: typeof(Object), description: "Validation Failed.")]
        [SwaggerResponse(statusCode: 404, type: typeof(Object), description: "Not Found.")]
        public virtual IActionResult AttributeNamespaceMetaPut([FromBody]Object body)
        {

            //TODO: Uncomment the next line to return response 200 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(200);
            //TODO: Uncomment the next line to return response 400 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(400, default(Object));
            //TODO: Uncomment the next line to return response 401 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(401);
            //TODO: Uncomment the next line to return response 404 or use other options such as return this.NotFound(), return this.BadRequest(..), ...
            // return StatusCode(404, default(Object));

            throw new NotImplementedException();
        }
    }
}
